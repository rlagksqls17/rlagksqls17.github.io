---  
title: "기계학습 정리 - 1장"
excerpt: "last_modified_at: 2021-04-30"
categories:
  - Blog
layout: post
tags:
  - Blog
use_math: True
last_modified_at: 2021-04-30T08:22:00~24:00
---  


[![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Frlagksqls17.github.io%2Fblog%2FMachLearn1%2F&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=HITS&edge_flat=true)](https://hits.seeyoufarm.com)  


빅데이터 분석 기사 결과도 아직 더 기다려야 하고, 본인이 흥미가 많기도 해서 당분간은 **기계학습과 웹 프로그래밍을 공부하며 간단히 정리 요약** 하려고 한다. 기계학습을 오전 오후에 공부하고, 웹 프로그래밍을 간단히 저녁에 공부하려 한다.  

---  

기계학습은 다음 서적을 참고하여 정리하였다.  
1장은 특히 빅데이터 분석기사 3과목을 풀 때 문제를 이해하는 데에 도움이 꽤 많이 되었다.

![KakaoTalk_20210430_231147826](https://imgur.com/yrLo7lR.jpg)  

연습 문제는 해답이 없어서 완전히 신뢰하기 보단 참고만 해주시길 부탁드린다.  

---  

## 1장 - 소개  

> 책에 있는 객관적인 내용은 정자로, 주관적으로 풀어쓴 의견은 기울임체로  작성하였다.
> 중요하다고 생각되는 내용은 **굵은 글자**로 작성하였다.  

기계학습이란, **특정한 응용 영역에서 발생하는 데이터(경험)를 이용하여 높은 성능으로 문제를 해결하는 컴퓨터 프로그램을 만드는 작업**을 뜻한다.  

>사람은 무슨일을 하든 처음에는 미숙하기 마련이다. 하지만 경험을 하면 할 수록 뇌에는 **정보**가 축적되고, 축적된 정보를 이용해 어떤 문제를 해결한다. 익숙해지면 전과 달리 아주 빨리 문제를 해결할 수 있다. **이러한 방식이 컴퓨터에서는 계산을 통해 이루어진다.**    

**즉 기계학습은 경험을 이용하는 계산학적 방법들이다.**  

1950년대에는 컴퓨터에 지능을 부여할 수 있다는 기대감이 한껏 부풀어 오르고 있었다. 그때 당시 여러 분야에서의 인공지능 적용 성과에 힘입어 문자 인식과 같은 패턴 인식 문제에도 도전하였는데, 당시에는 사람이 인식할 때 사용할 것으로 보이는 지식을 추려 프로그램에 심는 접근 방식을 사용하였다. 이러한 방식을 지식기반 또는 규칙기반 방식이라고 한다.  

하지만 만약 지식기반 접근방식을 사용해서 단추를 구분하기 위한 프로그램을 만든다고 하고, 지식기반의 일반적 접근 방식으로 단추를 '가운데 구멍이 몇 개 있는 둥근 물체'라고 서술하는 순간 수많은 단추들은 단추가 아닌 것이 되고 단추가 아닌 것이 단추가 된다.  
>  예를 들어 엽전을 단추라고 할 수 있는가? 또한 구멍이 한 개 있는 단추도 옷을 여밀 수 있으면 단추는 단추다. **즉 단추를 한마디로 정의하기 어렵다.**   

이러한 큰 깨달음 이후에 인공지능의 주도권은 서서히 지식기반 방식에서 기계 학습으로 넘어 갔다. 기계 학습은 데이터를 중심으로 하는 접근 방식을 채택한다. 즉 단추에 관한 데이터를 충분히 수집하여 미리 입력하고, 이렇게 사전에 입력된 데이터를 참고하여 앞으로 새로 들어올 이미지 데이터들을 분류한다. 이렇게 기계 학습 알고리즘은 데이터를 이용하여 스스로 학습해서 높은 성능을 보장하는 인식 프로그램을 자동으로 만든다.  

기계학습의 개념을 간단한 그래프를 이용해 이해해보자.  

![그래프2](https://imgur.com/SK6nJMW.jpg)  

어떤 함수에 2.0, 4.0, 6.0, 8.0인 특징 x을 입력하였더니, 위 그래프와 같이 2.0, 4.0, 6.0, 8.0인 목표치 y가 출력되었다고 가정하자. 이때 임의의 시간에 대한 이동체의 위치를 어떻게 예측할 수 있을까?  

이러한 형태의 문제를 예측이라 하며, **예측에는 회귀와 분류가 있다.** 위와 같이 실수값을 예측하는 문제를 회귀라 하고, 단추를 인식하는 것과 같은 문제는 분류라고 한다.  

기계 학습에서는 가로축에 해당하는 패턴을 특징이라고 하는데, 보통 '특징 벡터'라는 형태를 띤다. (2장에서 기술할 것이다) 아래 수식은 특징 벡터 집합과 목표값 집합을 표시하였다.

$X = \{x_1, x_2, x_3, x_4\}$, $Y = \{y_1, y_2, y_3, y_4\}$  

위의 4개의 {특징 x, 목표값 y} 쌍은 기계 학습에 주어지는 데이터로서, **훈련 집합 (training set)** 이라고 한다.  
대충 눈대중으로 살펴보면 훈련집합의 네 점이 직선을 이루므로 이들의 분포를 직선으로 표현하자.  
기계 학습에서는 이러한 의사결정을 **모델로 직선을 선택했다**라고 한다.  

> 물론 기계 학습 없이도 위의 직선 그래프가 $y = x$라는 것을 쉽게 알 수 있겠지만 기계학습의 개념을 알기 위해 우리는 위 그림에 있는 4개의 점만 알지 직선의 방정식은 아예 모른다고 가정한다.  

따라서 방정식을 아예 모를 때, 일단 기계 학습의 모델로 직선을 선택했으므로 다음의 식으로 표현 가능하다.  

$y=wx+b$  

> 여기서 w와 b를 **매개변수(parameter)** 라 하고, **이 매개변수를 구해야** 제대로 된 직선의 방정식이 구해져서 다른 데이터가 입력되어도 예측이 가능한 것이다.  

> 이 매개변수를 구하기 위한 계산방법이 있는데 이것은 일단 생략하고, 여차 저차 계산식을 구해서 위 그래프의 $f1$ 직선 방정식을 구했다고 치자. 단순히 $f1$과 4개의 점을 비교하면 서로 일치하지 않음을 알 수 있다.  

계속적인 계산과정을 통해 $f2$ 직선을 거쳐 최적인 $f3$에 도달하였다면, 이 모델은 성능이 점점 개선되는 과정을 거쳐 최적의 상태에 도달했다고 말할 수 있다. **이처럼 성능을 개선하면서 최적의 상태에 도달하는 작업을 학습 또는 훈련이라고 한다.**  

이렇게 학습 과정을 마치면 그때부터 학습된 모델을 이용하여 예측할 수 있다. 예를 들어, 10.0이라는 특징에서 목표값의 위치를 알고 싶으면 $f3(10.0) = 1(w 최적 매개변수) * 10.0 + 0(b 최적 매개변수)$ 를 계산하여 10.0을 출력할 수 있다.  
**이처럼 훈련 집합에 없는 새로운 샘플에 대한 목표값을 예측하는 과정을 테스트라 한다.**  
**새로운 샘플을 가진 데이터를 테스트 집합이라고 하고, 테스트 집합에 대해 높은 성능을 가진 성질을 일반화 능력이라 한다.**  

---  

이제 특징 공간에 대해 이해하여 보자.  

![특징공간](https://imgur.com/ATIra4w.jpg)    

* 위 그림은 해당 책의 그림 1-6에서 캡처해온 것이다.  

**차원이 증가하면 모델의 매개변수 개수가 함께 증가한다.**  

예를 들어, 위에서 기술한 것처럼 직선이라는 모델을 1차원에서는 2개의 매개변수(w, b)로 표현했는데, d차원에서는 이 식의 매개변수가 늘어난다.  

$y = w_1x_1 + w_2x_2 + ... + w_dx_d + b$  

2차 곡선을 만약 모델로 선택한다면 매개변수의 개수는 더 증가한다.  
Iris 분석 모델을 예로 든다면 d (*차원*) = 4이므로 매개변수의 수는 21, MNIST는 d = 784이므로 615441개의 매개변수를 가진다.  

> 그렇다면 각각의 차원을 가지는 특징공간들에서 임의의 수의 점들이 주어진다면 (예를 들어 3차원을 가지는 특징공간에서 임의의 점 10개가 주어진다면), 이 점과 점 사이의 거리를 어떻게 계산할까?  

흔히 배운바와 같이 피타고라스의 정리를 이용하여, 두 점 $a = (a_1, a_2, a_3)^T, b = (b_1, b_2, b_3)^T$가 주어진다면  $dist(a,b) = \sqrt()(a_1 - b_1)^2 + (a_2 - b_2)^2 + (a_3 - b_3)^2)$와 같이 계산할 수 있다.  

**고차원이 되면서 부터는 현실적인 문제가 발생한다.** 예를 들어 Iris데이터는 4차원이고, 이 네 축을 각각 100개 구간으로 나눈다면 1억 개의 칸으로 나뉜다. **이처럼 차원이 높아지면서 거대한 특징 공간이 형성되며, 이 때문에 발생하는 현실적인 문제를 차원의 저주(curse of dimensionality)라고 한다.**  
> 이 내용은 빅데이터 분석기사에서도 실제로 나온 문제이다.

---  

400년 전에도 지금도 데이터는 중요하다. 단추를 인식하는 모델을 단순한 공식으로 표현할 수 없다는 것을 이미 짐작했을 것이다. 인식 문제를 풀기 위해서는 충분히 많은 데이터를 수집한 후, 기계 학습 알고리즘에 입력하여 자동으로 모델을 찾아내게 하는 수 밖에 없다. **즉 데이터베이스의 품질이 무척 중요하다.** 예를 들어, 좋은 조명 아래에서 정면으로 촬영한 얼굴 영상을 모은 훈련집합을 사용하여 학습한 경우, 갸우뚱 한 얼굴이나 그림자가 진 얼굴을 인식하는 응용에서는 높은 성능을 기대할 수 없다. 다행히 많은 응용 분야에서 수집한 데이터베이스를 무료로 제공하는 경우가 많다.  

Iris 데이터베이스: 통계학자인 피셔 교수가 캐나다 동부 해안의 가스페 반도에 서식하는 3종의 붓꽃을 50송이씩 채취하여 만들었다. 150개 샘플 각각에 대해 꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비를 측정하여 기록하였다. [링크](https://archive.ics.uci.edu/ml/datasets.php)

MNIST 데이터베이스: 미국표준국(NIST)에서 수집한 필기 숫자 데이터 베이스로, 훈련집합 60000자, 테스트집합 10000자를 제공한다.  
[링크](http://yann.lecun.com/exdb/mnist)  

ImageNet 데이터베이스 : 정보검색 분야에서 만든 WordNet의 단어 계층 분류를 그대로 따랐고, 부류마다 수백에서 수천 개의 영상을 수집하였다. 총 21841개 부류에 대해 14197122개의 영상을 보유하고 있다. [링크](http://image-net.org)  

MNIST의 경우 훈련집합이 60000개 샘플인데 비해, 실제 이론적으로 가능한 서로 다른 샘플의 총 수는 $2^{784}$ 개이다. [Ciresan2012](https://arxiv.org/abs/1202.2745) 논문에서는 이렇게 무지막지한 발생가능한 샘플 중 단 60000개의 MNIST 훈련집합만 수집하여 0.23%의 낮은 오류율을 가진 인식 프로그램을 만든다. 어떻게 이러한 일이 가능할까?

1. 방대한 공간에서 실제 데이터가 발생하는 곳은 훨씬 작은 부분공간이다.  
> 즉 아무리 가능한 샘플이 $2^{784}$ 개라 할지라도, 거기서 숫자로 볼 수 있는 데이터 집합은 그리 크지 않다는 것이다.  

숫자 모양이 아닌 것이 훨씬 많을 것이며, 숫자 형태를 띠는 것은 작은 부분공간에 모여 있을 것이다.  

2. 발생하는 데이터가 심한 변화를 겪지만 일정한 규칙에 따라 매끄럽게 변한다.  
> 일단 위의 1번 주장에서 숫자 형태를 띠는 샘플들만 골라냈다고 가정하자. 골라낸 샘플들 중 2로 인식가능한 샘플들을 뽑아낼 때, 그 샘플 집합들은 그리 거칠게 변하지 않는다. 지금 본인의 얼굴 사진을 찍어보고, 그 사진을 편집해서 조금씩 기울이고 저장해보자. 10도 기울인 얼굴 사진, 20도 기울인 얼굴 사진도 모두 본인의 얼굴 사진으로 인식한다.  

이러한 가정을 매니폴드 가정이라 하는데, 6장에서 자세히 다룬다.  

---  

> 이제부터 이해하기 어려울 수 있는데, 천천히 한 문장씩 풀이패보도록 하자.  

![그래프2](https://imgur.com/SK6nJMW.jpg)  

그림을 다시 주목하자. 그림의 예제는 직선 모델을 사용하여 회귀 문제를 푸는데, 이러한 기계 학습 알고리즘을 선형 회귀라고 한다.  
선형 회귀는 직선 모델을 사용하므로 추정해야 할 매개변수는 y = wx + b에서 w와 b이다.  
> 지금 구하고 싶은 것이 네 개의 점을 이루는 직선의 방정식이다. 식을 아예 모른다는 가정하에 문제를 풀이할 것이다.  

>처음에는 최적의 매개변수 값을 알 수 없으므로, 난수를 생성하여 초기 매개변수를 설정해보자.  
${\theta}_1 = (w_1, b_1)^T = (2, 1)$ << **임의의 초기 값이다.**  

>매개변수가 설정되었으니, 우선 초기 모델의 방정식은 $y = 2x + 1$ 이라 할 수 있다.  

>실제 x와 y 값은 $X \{2, 4, 6, 8\}, Y\{2, 4, 6, 8\}$ 이 나와야한다. << 이게 훈련집합 (실제값)  

>하지만 초기 매개변수 설정 값에 따르면, 예측된 x와 y값은 $X\{2, 4, 6, 8\}, Y\{5, 9, 13, 17\}$ 이 나와버린다.  

>즉 실제값과 예측값 사이에 **오차**가 생겨버린다. 이 오차를 따로 계산하는 함수를 기계학습에서는 **목적함수**라 한다. 식은 다음과 같다.  

$J({\theta}) = {1/n}{\sum_{i = 1}^n (f_{\theta}(x_i)-y_i})^2$   

> 간단하게 오차를 구하는 함수라고 생각하면 편하다. 위 식을 풀어 오차를 구해보면  n이 10일 때 (n 값은 사용자가 정함)

$((5 - 2)^2 + (9 - 4)^2 + (13 - 6)^2 + (17 - 8)^2) / n = 16.4$ 이다.  

**우리의 주 목적은 이 오차를 최소화 시키는 것이다.**  

> 위에서 목적함수에 대해 설명하였다. 이름이 어렵게 생겨서 목적함수인거지 함수는 함수다. 위 방정식을 그려보면 직선 함수든 곡선 함수든 어떻게든 그래프로 표현될 것이다. **목적함수 그래프에서의 최저점이 바로 오차의 최저점이다. 이걸 찾으면 된다.**  


이때 목적함숫값이 작아지는 방향을 찾기 위해 주로 미분을 사용한다. 미분은 다음 장에서 자세히 다룬다.  

> 어쨌거나 목적함수를 미분하고, 거기에 아까 구했던 초기 매개변수 (w, b)를 대입하면 함수의 기울기 값이 나오는데, 함수의 기울기 값이 음수일 수록 '이 값 앞에 더한 최저점이 있다'라는 것을 뜻하므로, 프로그래밍할 때에는 기울기값이 더 이상 음수가 안 나올 때까지로 조건을 걸어두면 된다. (예외도 있지만, 그것은 나중에 설명하도록 하겠다.)  

이렇게 목적함수는 기계 학습이 최적의 성능을 찾아가는 데 등대같은 역할을 한다. **기계 학습 알고리즘은 목적함숫값이 작아지는 방향을 찾아 매개변수값을 조정하는 일을 반복**한다.  

> 매개변수 조정 시 ${\theta_{t+1}} = {\theta}_t + {\Delta}{\theta}_t$ 와 같이 미분값과 현재 매개변수 값을 서로 더하여 다음 최적의 매개변수 값을 찾는다.  

---  

![Imgur](https://i.imgur.com/SOHNWBZ.jpg)

* 참고한 책의 그림 1-13이다.  

곡선함수의 예측은 위 그림에서 보는 바와 같이 매개변수를 진행하면 진행할 수록 거의 완벽에 가깝게 학습이 되는 것을 볼 수 있다. 하지만 학습된 모델로 훈련집합에 없던 '새로운' 데이터를 예측한다면 크게 다른 평가를 해야만 한다.

> 4차와 12차를 비교해보라, 만약 12차 부분에서 빨간 실선 부분을 예측한다면 4차와 12차 중에서 어느 모델이 더 정확하게 예측할 것 같은가? 직관적으로 봤을 때 12차 보다는 4차 모델이 좀 더 자연스러운 예측이 가능할 것으로 보인다.  

12차 다항식이 모델로 적절하지 않은 이유는 역설적으로 용량이 너무 크기 때문이다.  
**주어진 데이터 분포와 비교해 용량이 너무 크다 보니 아주 작은 잡읍까지 수용한 것이다. 이러한 현상을 과잉적합이라 한다.**  

기계학습의 최종 목표는 훈련 집합에 없는 새로운 샘플을 정확하게 예측하는 것이므로 과소적합이나 과잉적합 모두 바람직하지 않다.  

그림의 12차 다항식 모델은 훈련집합에서는 아주 높은 성능을 보이지만, 테스트 집합에서는 아주 낮은 성능을 보이므로 일반화 능력이 무척 낮다고 할 수 있다. 또한 3차와 4차는 훈련집합과 테스트 집합의 성능 차이가 작아 일반화 능력이 뛰어나다고 할 수 있다.  

기계 학습의 궁극적인 목표는, 이런 일반화 능력을 **바이어스** 와 **분산** 이라는 개념으로 다르게 표현할 수 있다. 즉 낮은 바이어스와 낮은 분산을 가진 예측기를 만드는 것이 기계학습의 목표이다. 하지만 바이어스와 분산은 둘 중 하나를 낮추면 다른 것이 높아지는 **트레이드오프**라는 성질이 있기 때문에, 바이어스의 희생을 최소로 유지하면서 분산을 최대로 낮추는 전략을 써야 한다. 분산과 바이어스를 이해하기 위해선 다음 [링크](https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf) 에서 화살 과녁 그림을 참고하자.

---  

## 마치며

대강 이 정도면 이 책의 1장에서 알아야 할 정보를 써내려간 것 같다. 추가적인 내용이 아주 많지만, 책의 다음 장에 자세히 설명되니 내가 우선 학습하면서 조금씩 이해하고, 이해한 정보를 바탕으로 계속해서 포스팅 할 생각이다. 부디 본인의 글을 읽고 조금이나마 기계학습에 대해 이해했으면 좋겠다. (글을 써놓고도 내 자신이 이해를 잘 못하더라 ㅎㅎ)  

다음 포스팅에서는 선형 대수, 확률과 통계, 최적화에 관해 글을 써내려 가도록 하겠다.  
